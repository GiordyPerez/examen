CREATE TABLE [dbo].[errores](
	[id_error] [int] IDENTITY(1,1) NOT NULL,
	[numero_error] [varchar](50) NULL,
	[mensaje_error] [varchar](max) NULL,
	[procedimiento_error] [varchar](50) NULL,
	[linea_error] [varchar](50) NULL,
	[fecha] [date] NULL,
    PRIMARY KEY CLUSTERED (id_error)
)
GO

CREATE TABLE [dbo].[ciudades](
	[id_ciudad] [int] IDENTITY(1,1) NOT NULL,
	[ciudad] [varchar](25) NULL,
	[direccion] [varchar](25) NULL,
	[telefono] [int] NULL,
	[no_orden] [int] NULL,
	[estado] [bit] NOT NULL,
    PRIMARY KEY CLUSTERED (id_ciudad)
) 
GO

CREATE TABLE [dbo].[rutas](
	[id_ruta] [int] IDENTITY(1,1) NOT NULL,
	[ruta] [varchar](25) NULL,
	[km_totales_recorridos] [int] NULL,
	[origen] [varchar](25) NULL,
	[final] [varchar](25) NULL,
	[id_ciudad] [int] NOT NULL,
	[estado] [bit] NOT NULL,
    PRIMARY KEY CLUSTERED (id_ruta)
) 
GO

ALTER TABLE [dbo].[rutas]  WITH CHECK ADD  CONSTRAINT [FK_rutas_ciudades] FOREIGN KEY([id_ciudad])
REFERENCES [dbo].[ciudades] ([id_ciudad])
GO

ALTER TABLE [dbo].[rutas] CHECK CONSTRAINT [FK_rutas_ciudades]
GO

CREATE TABLE [dbo].[buses](
	[id_bus] [int] IDENTITY(1,1) NOT NULL,
	[bus] [varchar](25) NULL,
	[matricula] [varchar](25) NULL,
	[modelo] [nchar](10) NULL,
	[capacidad_asientos] [int] NULL,
	[nombre_piloto] [varchar](25) NULL,
	[estado_bus] [bit] NULL,
	[id_ruta] [int] NOT NULL,
    PRIMARY KEY CLUSTERED (id_bus)
) 
GO

ALTER TABLE [dbo].[buses]  WITH CHECK ADD  CONSTRAINT [FK_buses_rutas] FOREIGN KEY([id_ruta])
REFERENCES [dbo].[rutas] ([id_ruta])
GO

ALTER TABLE [dbo].[buses] CHECK CONSTRAINT [FK_buses_rutas]
GO

CREATE TABLE [dbo].[paradas](
	[id_parada] [int] IDENTITY(1,1) NOT NULL,
	[parada] [varchar](25) NULL,
	[id_ruta] [int] NOT NULL,
	[estado] [bit] NOT NULL,
    PRIMARY KEY CLUSTERED (id_parada)
) 
GO


ALTER TABLE [dbo].[paradas]  WITH CHECK ADD  CONSTRAINT [FK_paradas_rutas] FOREIGN KEY([id_ruta])
REFERENCES [dbo].[rutas] ([id_ruta])
GO

ALTER TABLE [dbo].[paradas] CHECK CONSTRAINT [FK_paradas_rutas]
GO


CREATE TABLE dbo.bitacora
  (
     id_bitacora     int IDENTITY(1, 1) NOT NULL,
     bitacoraTabla   VARCHAR(250) NOT NULL,
     bitacoraTablaID INT NOT NULL,
     bitacoraAccion  CHAR(1) NULL,
     bitacoraUsuario VARCHAR(255) NULL,
     bitacoraFecha   DATETIME NULL DEFAULT GetDate(),
     bitacoraAntes   NVARCHAR(MAX) NULL,
     bitacoraDespues NVARCHAR(MAX) NULL,
    PRIMARY KEY CLUSTERED (id_bitacora)
  )
GO

Create PROC sp_ciudades @Operacion int,@id_ciudad int, @ciudad varchar(25),@direccion varchar(25)
,@telefono int,@no_orden  int, @estado bit
AS

begin transaction
		begin try
--Operacion Insertar
IF @Operacion='1'
BEGIN 
INSERT INTO ciudades(ciudad,direccion,telefono,no_orden,estado)
 VALUES(@ciudad,@direccion,@telefono,@no_orden, @estado)
END

--Operacion Actualizar
IF @Operacion='2'
BEGIN 
update ciudades set ciudad=@ciudad,direccion=@direccion,telefono=@telefono,no_orden=@no_orden, estado=@estado
where id_ciudad =@id_ciudad

END

--Operacion Actualizar estado id
IF @Operacion='3'
BEGIN 
update ciudades set estado=@estado where id_ciudad =@id_ciudad
END

--Operacion select a la tabla
IF @Operacion='4'
BEGIN 
Select id_ciudad,ciudad, direccion,telefono,no_orden, estado from ciudades
END;

	commit transaction
		end try
			begin catch
				rollback transaction	
			insert into dbo.errores
select ERROR_NUMBER(),ERROR_MESSAGE(),ERROR_PROCEDURE(),ERROR_LINE(),GETDATE();
  			end catch;

----
Create PROC sp_rutas @Operacion int,@id_ruta int, @ruta varchar(25),@km_tot int,@origen varchar(25),
@final  varchar(25),@id_ciudad int, @estado bit
AS

begin transaction
		begin try
--Operacion Insertar
IF @Operacion='1'
BEGIN 
INSERT INTO rutas(ruta,km_totales_recorridos ,origen,final,id_ciudad, estado)
 VALUES(@ruta,@km_tot,@origen,@final,@id_ciudad, @estado)
END

--Operacion Actualizar
IF @Operacion='2'
BEGIN 
update rutas set ruta=@ruta,km_totales_recorridos=@km_tot,origen=@origen,final=@final,id_ciudad=@id_ciudad, estado=@estado
where id_ruta =@id_ruta

END

--Operacion Actualizar estado id
IF @Operacion='3'
BEGIN 
update rutas set estado=@estado where id_ruta=@id_ruta
END

--Operacion select a la tabla
IF @Operacion='4'
BEGIN 
select id_ruta, ruta, km_totales_recorridos, origen, final,c.id_ciudad, c.ciudad,r.estado from rutas as r inner join ciudades as c on c.id_ciudad = r.id_ciudad 
END;

	commit transaction
		end try
			begin catch
				rollback transaction	
			insert into dbo.errores
select ERROR_NUMBER(),ERROR_MESSAGE(),ERROR_PROCEDURE(),ERROR_LINE(),GETDATE();
  			end catch;
------
Create PROC sp_buses @Operacion int,@id_bus int, @bus varchar(25),@matricula varchar(25),@modelo varchar(25),
@capacidad_asientos int,@nombre_piloto varchar(25), @estado_bus bit, @id_ruta int
AS

begin transaction
		begin try
--Operacion Insertar
IF @Operacion='1'
BEGIN 
INSERT INTO buses(bus,matricula,modelo,capacidad_asientos,nombre_piloto,estado_bus,id_ruta)
 VALUES(@bus,@matricula,@modelo,@capacidad_asientos,@nombre_piloto,@estado_bus, @id_ruta )
END

--Operacion Actualizar
IF @Operacion='2'
BEGIN 
update buses set bus=@bus,matricula=@matricula,modelo=@modelo,capacidad_asientos=@capacidad_asientos,nombre_piloto=@nombre_piloto
,estado_bus=@estado_bus, id_ruta=@id_ruta where id_bus=@id_bus

END

--Operacion Actualizar estado id
IF @Operacion='3'
BEGIN 
update buses set estado_bus=@estado_bus where id_bus=@id_bus
END

--Operacion select a la tabla
IF @Operacion='4'
BEGIN 
select id_bus, bus, matricula, modelo,capacidad_asientos,nombre_piloto,estado_bus,r.ruta, b.id_ruta  from buses as b
inner join rutas as r  on b.id_ruta= r.id_ruta 
END;

	commit transaction
		end try
			begin catch
				rollback transaction	
			insert into dbo.errores
select ERROR_NUMBER(),ERROR_MESSAGE(),ERROR_PROCEDURE(),ERROR_LINE(),GETDATE();
  			end catch;
------
Create PROC sp_paradas @Operacion int,@id_parada int, @parada varchar(25),@id_ruta int, @estado bit
AS

begin transaction
		begin try
--Operacion Insertar
IF @Operacion='1'
BEGIN 
INSERT INTO paradas(parada,id_ruta,estado)
 VALUES(@parada,@id_ruta, @estado)
END

--Operacion Actualizar
IF @Operacion='2'
BEGIN 
update paradas set parada=@parada,id_ruta=@id_ruta, estado=@estado
where id_parada =@id_parada

END

--Operacion Actualizar estado id
IF @Operacion='3'
BEGIN 
update paradas set estado=@estado where id_parada =@id_parada
END

--Operacion select a la tabla
IF @Operacion='4'
BEGIN 
select id_parada,parada,  p.id_ruta,r.ruta, p.estado from paradas as p inner join rutas as r on r.id_ruta = p.id_ruta
END;

	commit transaction
		end try
			begin catch
				rollback transaction	
			insert into dbo.errores
select ERROR_NUMBER(),ERROR_MESSAGE(),ERROR_PROCEDURE(),ERROR_LINE(),GETDATE();
  			end catch;
------------------
CREATE FUNCTION dbo.fn_ruta_bus (@id_bus int)  
RETURNS varchar(25)  
AS   

BEGIN  
    DECLARE @ret varchar(25);  
    SELECT @ret = r.ruta   
    FROM buses as b inner join rutas as r  on b.id_ruta= r.id_ruta
    WHERE b.id_bus = @id_bus    
    RETURN @ret;  
END; 
--select dbo.fn_ruta_bus ('6');
--select dbo.fn_ruta_bus ('2');
--select dbo.fn_ruta_bus ('4');
------------------
CREATE TRIGGER dbo.trigger_ciudades
ON dbo.ciudades
AFTER INSERT, UPDATE, DELETE
NOT FOR REPLICATION
AS
  BEGIN
      SET NOCOUNT ON;
      SET ANSI_WARNINGS OFF;

      DECLARE @accion          CHAR(1) = 'I',
              @BitacoraTabla   VARCHAR(250),
              @BitacoraTablaID INT,
              @BitacoraUsuario VARCHAR(250),
              @Llave           INT;

      SELECT @accion = CASE
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'U'
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND NOT EXISTS (SELECT TOP 1 1
                                              FROM   DELETED) THEN
                           'I'
                         WHEN NOT EXISTS (SELECT TOP 1 1
                                          FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'D'
                       END;

      SELECT @BitacoraUsuario = SYSTEM_USER,
             @BitacoraTablaID = parent_object_id,
             @BitacoraTabla = Schema_name(schema_id) + '.'
                              + Object_name(parent_object_id)
      FROM   sys.objects o (nolock)
      WHERE  o.NAME = Object_name(@@PROCID)
             AND Schema_name(o.schema_id) = Object_schema_name(@@PROCID);

      DECLARE TrCursor CURSOR FOR -- Cursor 
		SELECT ISNULL(d.id_ciudad, i.id_ciudad) AS ID_BUS
		FROM   INSERTED I (nolock)
			   FULL JOIN DELETED d (nolock)
					  ON d.id_ciudad = i.id_ciudad
		ORDER  BY ISNULL(i.id_ciudad, d.id_ciudad) 


      OPEN TrCursor;

      FETCH NEXT FROM TrCursor INTO @Llave;

      WHILE @@FETCH_STATUS = 0 
        BEGIN
            --inicio: Bitacora
            INSERT INTO dbo.bitacora
            (
              bitacoraTabla,
              bitacoraTablaID,
              bitacoraAccion,
              bitacoraUsuario,
              bitacoraAntes,
              bitacoraDespues
            )
            VALUES
            (
              @BitacoraTabla,
              @BitacoraTablaID,
              @accion,
              @BitacoraUsuario,
              (SELECT * FROM DELETED d (nolock) WHERE d.id_ciudad = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER),
              (SELECT * FROM INSERTED i (nolock) WHERE  i.id_ciudad = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
            )
            --Fin:SE COLOCA LO QUE SE REPETIRA
            FETCH NEXT FROM TrCursor INTO @Llave;
        END

      CLOSE TrCursor; -- Se cierra el cursor
      DEALLOCATE TrCursor; -- Liberamos memoria
  END 
-------------
CREATE TRIGGER dbo.trigger_rutas
ON dbo.rutas
AFTER INSERT, UPDATE, DELETE
NOT FOR REPLICATION
AS
  BEGIN
      SET NOCOUNT ON;
      SET ANSI_WARNINGS OFF;

      DECLARE @accion          CHAR(1) = 'I',
              @BitacoraTabla   VARCHAR(250),
              @BitacoraTablaID INT,
              @BitacoraUsuario VARCHAR(250),
              @Llave           INT;

      SELECT @accion = CASE
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'U'
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND NOT EXISTS (SELECT TOP 1 1
                                              FROM   DELETED) THEN
                           'I'
                         WHEN NOT EXISTS (SELECT TOP 1 1
                                          FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'D'
                       END;

      SELECT @BitacoraUsuario = SYSTEM_USER,
             @BitacoraTablaID = parent_object_id,
             @BitacoraTabla = Schema_name(schema_id) + '.'
                              + Object_name(parent_object_id)
      FROM   sys.objects o (nolock)
      WHERE  o.NAME = Object_name(@@PROCID)
             AND Schema_name(o.schema_id) = Object_schema_name(@@PROCID);

      DECLARE TrCursor CURSOR FOR -- Cursor 
		SELECT ISNULL(d.id_ruta, i.id_ruta) AS ID_BUS
		FROM   INSERTED I (nolock)
			   FULL JOIN DELETED d (nolock)
					  ON d.id_ruta = i.id_ruta
		ORDER  BY ISNULL(i.id_ruta, d.id_ruta) 


      OPEN TrCursor;

      FETCH NEXT FROM TrCursor INTO @Llave;

      WHILE @@FETCH_STATUS = 0 
        BEGIN
            --inicio: Bitacora
            INSERT INTO dbo.bitacora
            (
              bitacoraTabla,
              bitacoraTablaID,
              bitacoraAccion,
              bitacoraUsuario,
              bitacoraAntes,
              bitacoraDespues
            )
            VALUES
            (
              @BitacoraTabla,
              @BitacoraTablaID,
              @accion,
              @BitacoraUsuario,
              (SELECT * FROM DELETED d (nolock) WHERE d.id_ruta = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER),
              (SELECT * FROM INSERTED i (nolock) WHERE  i.id_ruta = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
            )
            --Fin:SE COLOCA LO QUE SE REPETIRA
            FETCH NEXT FROM TrCursor INTO @Llave;
        END

      CLOSE TrCursor; -- Se cierra el cursor
      DEALLOCATE TrCursor; -- Liberamos memoria
  END 
-------------------------------
CREATE TRIGGER dbo.trigger_buses
ON dbo.buses
AFTER INSERT, UPDATE, DELETE
NOT FOR REPLICATION
AS
  BEGIN
      SET NOCOUNT ON;
      SET ANSI_WARNINGS OFF;

      DECLARE @accion          CHAR(1) = 'I',
              @BitacoraTabla   VARCHAR(250),
              @BitacoraTablaID INT,
              @BitacoraUsuario VARCHAR(250),
              @Llave           INT;

      SELECT @accion = CASE
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'U'
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND NOT EXISTS (SELECT TOP 1 1
                                              FROM   DELETED) THEN
                           'I'
                         WHEN NOT EXISTS (SELECT TOP 1 1
                                          FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'D'
                       END;

      SELECT @BitacoraUsuario = SYSTEM_USER,
             @BitacoraTablaID = parent_object_id,
             @BitacoraTabla = Schema_name(schema_id) + '.'
                              + Object_name(parent_object_id)
      FROM   sys.objects o (nolock)
      WHERE  o.NAME = Object_name(@@PROCID)
             AND Schema_name(o.schema_id) = Object_schema_name(@@PROCID);

      DECLARE TrCursor CURSOR FOR -- Cursor 
		SELECT ISNULL(d.id_bus, i.id_bus) AS ID_BUS
		FROM   INSERTED I (nolock)
			   FULL JOIN DELETED d (nolock)
					  ON d.id_bus = i.id_bus
		ORDER  BY ISNULL(i.id_bus, d.id_bus) 


      OPEN TrCursor;

      FETCH NEXT FROM TrCursor INTO @Llave;

      WHILE @@FETCH_STATUS = 0 
        BEGIN
            --inicio: Bitacora
            INSERT INTO dbo.bitacora
            (
              bitacoraTabla,
              bitacoraTablaID,
              bitacoraAccion,
              bitacoraUsuario,
              bitacoraAntes,
              bitacoraDespues
            )
            VALUES
            (
              @BitacoraTabla,
              @BitacoraTablaID,
              @accion,
              @BitacoraUsuario,
              (SELECT * FROM DELETED d (nolock) WHERE d.id_bus = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER),
              (SELECT * FROM INSERTED i (nolock) WHERE  i.id_bus = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
            )
            --Fin:SE COLOCA LO QUE SE REPETIRA
            FETCH NEXT FROM TrCursor INTO @Llave;
        END

      CLOSE TrCursor; -- Se cierra el cursor
      DEALLOCATE TrCursor; -- Liberamos memoria
  END
-------------------
CREATE TRIGGER dbo.trigger_paradas
ON dbo.paradas
AFTER INSERT, UPDATE, DELETE
NOT FOR REPLICATION
AS
  BEGIN
      SET NOCOUNT ON;
      SET ANSI_WARNINGS OFF;

      DECLARE @accion          CHAR(1) = 'I',
              @BitacoraTabla   VARCHAR(250),
              @BitacoraTablaID INT,
              @BitacoraUsuario VARCHAR(250),
              @Llave           INT;

      SELECT @accion = CASE
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'U'
                         WHEN EXISTS (SELECT TOP 1 1
                                      FROM   INSERTED)
                              AND NOT EXISTS (SELECT TOP 1 1
                                              FROM   DELETED) THEN
                           'I'
                         WHEN NOT EXISTS (SELECT TOP 1 1
                                          FROM   INSERTED)
                              AND EXISTS (SELECT TOP 1 1
                                          FROM   DELETED) THEN
                           'D'
                       END;

      SELECT @BitacoraUsuario = SYSTEM_USER,
             @BitacoraTablaID = parent_object_id,
             @BitacoraTabla = Schema_name(schema_id) + '.'
                              + Object_name(parent_object_id)
      FROM   sys.objects o (nolock)
      WHERE  o.NAME = Object_name(@@PROCID)
             AND Schema_name(o.schema_id) = Object_schema_name(@@PROCID);

      DECLARE TrCursor CURSOR FOR -- Cursor 
		SELECT ISNULL(d.id_parada, i.id_parada) AS ID_BUS
		FROM   INSERTED I (nolock)
			   FULL JOIN DELETED d (nolock)
					  ON d.id_parada = i.id_parada
		ORDER  BY ISNULL(i.id_parada, d.id_parada) 


      OPEN TrCursor;

      FETCH NEXT FROM TrCursor INTO @Llave;

      WHILE @@FETCH_STATUS = 0 
        BEGIN
            --inicio: Bitacora
            INSERT INTO dbo.bitacora
            (
              bitacoraTabla,
              bitacoraTablaID,
              bitacoraAccion,
              bitacoraUsuario,
              bitacoraAntes,
              bitacoraDespues
            )
            VALUES
            (
              @BitacoraTabla,
              @BitacoraTablaID,
              @accion,
              @BitacoraUsuario,
              (SELECT * FROM DELETED d (nolock) WHERE d.id_parada = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER),
              (SELECT * FROM INSERTED i (nolock) WHERE  i.id_parada = @Llave FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
            )
            --Fin:SE COLOCA LO QUE SE REPETIRA
            FETCH NEXT FROM TrCursor INTO @Llave;
        END

      CLOSE TrCursor; -- Se cierra el cursor
      DEALLOCATE TrCursor; -- Liberamos memoria
  END 
---------------
use db_transport
select * from vista_reporte;
-------------
